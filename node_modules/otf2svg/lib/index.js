#!/usr/bin/env node
"use strict";

var fontkit = require('fontkit');

function zeroPad(str, length) {
  var ret = str;

  while (ret.length < length) {
    ret = '0' + ret;
  }

  return ret;
}

function toUnicodeStr(codePoints) {
  var ret = null;
  var foundControlCode = false;

  for (var codePointIndex = 0; codePoints != null && Array.isArray(codePoints) && codePointIndex < codePoints.length; codePointIndex++) {
    var codePoint = codePoints[codePointIndex];

    if (codePoint >= 32) {
      //character shouldn't be mapped to control code
      var hex = codePoint.toString(16).toLowerCase();
      hex = (hex.length % 2 == 0 ? '' : '0') + hex;
      ret = (ret == null ? '' : ret) + '&#x' + hex + ';';
    } else {
      foundControlCode = true;
    }
  }

  return foundControlCode ? null : ret;
}

function glyphDef(codePoints, svgPath, name, advanceWidth, isMissing) {
  var unicodeCodePointStr = toUnicodeStr(codePoints);
  var path = "";

  if (isMissing || unicodeCodePointStr != null) {
    var aw = advanceWidth != null ? 'horiz-adv-x="' + advanceWidth + '"' : '';
    var gn = name != null ? 'glyph-name="' + name + '" ' : '';
    var start = isMissing ? '<missing-glyph ' : '<glyph ' + gn + 'unicode="' + unicodeCodePointStr + '" ';
    path = start + aw + ' d="' + svgPath + '" />';
  }

  return path;
} // string is unchanged, integer => string, integer array => string


function codePointDefToMapKey(codePointDef) {
  var ret = '';

  if (typeof codePointDef == 'string') {
    ret = codePointDef;
  }

  if (typeof codePointDef == 'number' || typeof codePointDef == 'bigint') {
    ret = String.fromCodePoint(codePointDef);
  }

  if (Array.isArray(codePointDef)) {
    for (var ai = 0; ai < codePointDef.length; ai++) {
      var nxt = codePointDef[ai];
      ret = ret + (typeof nxt == 'string' ? nxt : String.fromCodePoint(nxt));
    }
  }

  return ret;
}

function convert(otfInput) {
  var subsetCodePoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var font = null;

  if (Buffer.isBuffer(otfInput)) {
    font = fontkit.create(otfInput);
  } else {
    font = fontkit.openSync(otfInput);
  }

  var glyphDefs = [];
  var missing = font.getGlyph(0);
  glyphDefs.push(glyphDef(0, missing.path.toSVG(), missing.name, missing.advanceWidth, true));
  var subsetCodePointMap = {};

  for (var scpi = 0; subsetCodePoints != null && scpi < subsetCodePoints.length; scpi++) {
    subsetCodePointMap[codePointDefToMapKey(subsetCodePoints[scpi])] = true;
  }

  var codePoints = font.characterSet.sort(function (a, b) {
    return a - b;
  });
  var seenCodePoints = {};
  var seenGlyphIds = {};
  codePoints.forEach(function (codePoint) {
    var glyph = font.glyphForCodePoint(codePoint);

    if (glyph != null && glyph.id != missing.id && (subsetCodePoints == null || subsetCodePoints.length == 0 || subsetCodePointMap[codePointDefToMapKey(codePoint)] != null)) {
      var nextGlyphDef = glyphDef([codePoint], glyph.path.toSVG(), glyph.name, glyph.advanceWidth, false);

      if (nextGlyphDef != '') {
        glyphDefs.push(nextGlyphDef);
      }

      seenCodePoints[codePoint] = true;
      seenGlyphIds[glyph.id] == true;
    }
  });
  /*
    Ligatures:
      SVG allows only one unicode sequence per glyph
      This means we can't preserve alternate glyphs when glyph already maps to a unicode code point
      Additionally, if a glyph is already defined for a single unicode code point we can't map an alternate for that single unicode code point
      Finally, SVG does not support "Chaining Contextual Substitution" where the context of the codepoint determines whether substitution happens, so these glyphs will be ignored
       However, when glyph is defined ONLY as a ligature, that is, one that maps to a sequence of  two or more code points, we can preserve those here.
  */

  try {
    var lookupList = font.GSUB.lookupList.toArray();
    lookupList.forEach(function (entry) {
      if (entry.lookupType == 4) {
        entry.subTables.forEach(function (subtable) {
          try {
            var lset = subtable.ligatureSets.toArray();
            lset.forEach(function (lsubset) {
              lsubset = Array.isArray(lsubset) ? lsubset : [lsubset];
              lsubset.forEach(function (ligature) {
                if (seenGlyphIds[ligature.glyph] == null && ligature.components.length > 1 && (subsetCodePoints == null || subsetCodePoints.length == 0 || subsetCodePointMap[codePointDefToMapKey(ligature.components)] != null)) {
                  var glyph = font.getGlyph(ligature.glyph);
                  var nextGlyphDef = glyphDef(ligature.components, glyph.path.toSVG(), glyph.name, glyph.advanceWidth, false);

                  if (nextGlyphDef != '') {
                    glyphDefs.push(nextGlyphDef);
                  }
                }
              });
            });
          } catch (innerErr) {}
        });
      }
    });
  } catch (outerErr) {}

  var sortedCodePoints = Object.keys(seenCodePoints).sort(function (a, b) {
    return a - b;
  });
  var uRangeDef = 'U+' + zeroPad(sortedCodePoints[0].toString(16), 8) + '-' + zeroPad(sortedCodePoints[sortedCodePoints.length - 1].toString(16), 8);
  var bboxDef = font.bbox.minX + "," + font.bbox.minY + "," + font.bbox.maxX + "," + font.bbox.maxY;
  var panoseDef = font['OS/2'].panose != null ? font['OS/2'].panose : '0 0 0 0 0 0 0 0 0 0';
  var weight = font['OS/2'].usWeightClass != null ? '" weight="' + font['OS/2'].usWeightClass : '';
  var header = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" ><svg xmlns="http://www.w3.org/2000/svg"><metadata></metadata><defs>\n';
  var fontDef = '<font id="' + font.postscriptName + "\" >\n";
  var fontFaceDef = '<font-face font-family="' + font.familyName + '" font-stretch="normal" units-per-em="' + font.unitsPerEm + weight + '" panose-1="' + panoseDef + '" ascent="' + font.ascent + '" descent="' + font.descent + '" x-height="' + font.xHeight + '" underline-thickness="' + font.underlineThickness + '" underline-position="' + font.underlinePosition + '" unicode-range="' + uRangeDef + '" bbox="' + bboxDef + '" />\n';
  var footer = '</font>\n</defs>\n</svg>';
  return header + fontDef + fontFaceDef + glyphDefs.join("\n") + footer;
}

function convertToFile(otfInput) {
  var svgOutputPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var subsetCodePoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var fs = require('fs');

  var svgData = convert(otfInput, subsetCodePoints);

  if (svgOutputPath == null && !Buffer.isBuffer(otfInput)) {
    svgOutputPath = otfInput.replace(/\.[^.]*$/, '') + ".svg";
  }

  if (svgOutputPath == null) {
    svgOutputPath = "output.svg";
  }

  fs.writeFileSync(svgOutputPath, svgData);
  return svgOutputPath;
}

function cli() {
  var otfInputPath = process.argv[2];
  var svgOutputPath = process.argv[3];

  if (otfInputPath == null) {
    console.warn("ERROR: No Input OTF File specified.");
    process.exit(1);
  }

  console.log("Converting " + otfInputPath);

  try {
    svgOutputPath = convertToFile(otfInputPath, svgOutputPath);
  } catch (err) {
    console.log("ERROR: " + err);
    process.exit(1);
  }

  console.log("Done.");
  console.log(svgOutputPath + " has been created.");
  process.exit(0);
}

if (require.main === module) {
  cli();
}

exports.convert = convert;
exports.convertToFile = convertToFile;